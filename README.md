# Лабы по сетевому программированию (Python, вариант 12)

Репозиторий с решениями лабораторных работ по сетевому программированию (1 семестр), язык — **Python 3**, ОС — **Linux**.

## Структура репозитория

```text
.
├── lab1/          # ЛР1: базовый клиент‑сервер
├── lab2/          # ЛР2: расширение протокола
├── lab3/          # ЛР3: устойчивость/таймауты
├── lab4/          # ЛР4: параллельный сервер
└── README.md
```

Дальше структура будет уточняться, но папки под лабы фиксированы.

## Требования

- Linux
- Python 3.10+
- (опционально) virtualenv

## Быстрый старт

```bash
git clone <url>
cd <repo>

python3 -m venv venv
source venv/bin/activate

# пока зависимостей нет
# pip install -r requirements.txt
```

## ЛР1 (черновой интерфейс)

Директория: `lab1/`

Задача: минимальный клиент‑сервер (TCP/UDP по условию варианта 12), обмен сообщениями по заданному формату.

Ожидаемые файлы:

- `lab1/server.py` — запуск сервера
- `lab1/client.py` — запуск клиента

Пример запуска (интерфейс может меняться, но базово так):

```bash
cd lab1
python3 server.py --host 0.0.0.0 --port 9000

python3 client.py --host 127.0.0.1 --port 9000
```

Протокол и формат сообщений для варианта 12 будут оформлены в `common/protocol.py` и/или `lab1/README.md`.

## ЛР4 (черновой интерфейс)

Директория: `lab4/`

Задача: многопоточный сервер, параллельная обработка запросов, ограничение числа клиентов, тот же протокол варианта 12.

Ожидаемые файлы:

- `lab4/server.py` — многопоточный сервер
- при необходимости — отдельные модули пула потоков в `common/`

Пример запуска:

```bash
cd lab4
python3 server.py --host 0.0.0.0 --port 9000 --max-clients 10
```

## Общие модули

Директория: `common/` (планируется):

- `protocol.py` — описание протокола варианта 12, разбор/сборка сообщений
- `config.py` — порты, таймауты, константы
- `utils.py` — вспомогательные функции (логирование, проверки и т.п.)

## Правила кодовой базы

- Один протокол на весь семестр, эволюционирует от ЛР1 к ЛР4.
- Никакой логики в `if __name__ == "__main__":`, только запуск.
- Сетевой код — только через модуль `socket`, многопоточность — через `threading`.